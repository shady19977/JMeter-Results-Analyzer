<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JMeter JTL Analyzer - 1GB Support</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #e2e8f0;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
        }
        
        .header h1 {
            font-size: 2.5rem;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .header p {
            color: #94a3b8;
            font-size: 1.1rem;
        }
        
        .upload-section {
            background: #1e293b;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #475569;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-section:hover {
            border-color: #10b981;
            background: #334155;
        }
        
        .upload-section input {
            display: none;
        }
        
        .upload-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }
        
        .file-name {
            color: #10b981;
            margin-top: 15px;
            font-weight: bold;
        }
        
        .progress-container {
            width: 100%;
            background: #334155;
            border-radius: 8px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 30px;
            background: linear-gradient(90deg, #10b981, #059669);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .processing-status {
            margin-top: 10px;
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        .stat-card.success {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }
        
        .stat-card.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
        }
        
        .stat-card.danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        
        .stat-card.info {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
        }
        
        .stat-card.network {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
        }
        
        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-bottom: 8px;
        }
        
        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
        }
        
        .stat-unit {
            font-size: 1rem;
            opacity: 0.8;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-container {
            background: #1e293b;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            border: 1px solid #334155;
            position: relative;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #334155;
        }
        
        .chart-title {
            font-size: 1.2rem;
            color: #fff;
            font-weight: 600;
        }
        
        .chart-subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
        }
        
        .chart-wrapper {
            position: relative;
            height: 300px;
        }
        
        .details-section {
            background: #1e293b;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 20px;
        }
        
        .details-title {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .percentile-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .percentile-table th,
        .percentile-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #334155;
        }
        
        .percentile-table th {
            background: #334155;
            color: #10b981;
        }
        
        .ai-insights {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.4);
        }
        
        .ai-insights h2 {
            color: #10b981;
            font-size: 1.8rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .insight-section {
            margin-bottom: 25px;
        }
        
        .insight-section h3 {
            color: #60a5fa;
            font-size: 1.3rem;
            margin-bottom: 12px;
            border-left: 4px solid #10b981;
            padding-left: 12px;
        }
        
        .insight-section p, .insight-section ul {
            color: #cbd5e1;
            line-height: 1.8;
            margin-bottom: 10px;
        }
        
        .insight-section ul {
            list-style: none;
            padding-left: 0;
        }
        
        .insight-section li {
            padding: 8px 0;
            padding-left: 25px;
            position: relative;
        }
        
        .insight-section li:before {
            content: "‚ñ∏";
            position: absolute;
            left: 5px;
            color: #10b981;
            font-weight: bold;
        }
        
        .status-badge {
            display: inline-block;
            padding: 6px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        
        .status-excellent {
            background: #059669;
            color: white;
        }
        
        .status-good {
            background: #10b981;
            color: white;
        }
        
        .status-fair {
            background: #f59e0b;
            color: white;
        }
        
        .status-poor {
            background: #ef4444;
            color: white;
        }
        
        .hidden {
            display: none;
        }
        
        .tabs {
            display: flex;
            gap: 5px;
            background: #1e293b;
            padding: 5px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            background: #334155;
            border: none;
            color: #94a3b8;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .tab:hover {
            background: #475569;
            color: #e2e8f0;
        }
        
        .tab.active {
            background: #3b82f6;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .no-data {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 250px;
            color: #94a3b8;
        }
        
        .no-data-icon {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.5;
        }
        
        canvas {
            max-height: 400px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä JMeter Performance Analyzer Pro By Shady Gomaa</h1>
            <p>Advanced Performance Testing - Supports files up to 1GB</p>
        </div>

        <div class="upload-section" onclick="document.getElementById('fileInput').click()">
            <div class="upload-icon">üìÅ</div>
            <div>Click to upload .jtl or .csv file (supports large files up to 1GB)</div>
            <input type="file" id="fileInput" accept=".jtl,.csv">
            <div id="fileName" class="file-name hidden"></div>
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
            <div id="processingStatus" class="processing-status hidden"></div>
        </div>

        <div id="results" class="hidden">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Total Requests</div>
                    <div class="stat-value" id="totalRequests">0</div>
                </div>
                <div class="stat-card success">
                    <div class="stat-label">Success Rate</div>
                    <div class="stat-value" id="successRate">0<span class="stat-unit">%</span></div>
                </div>
                <div class="stat-card warning">
                    <div class="stat-label">Avg Response Time</div>
                    <div class="stat-value" id="avgResponse">0<span class="stat-unit">ms</span></div>
                </div>
                <div class="stat-card danger">
                    <div class="stat-label">Throughput</div>
                    <div class="stat-value" id="throughput">0<span class="stat-unit">req/s</span></div>
                </div>
                <div class="stat-card network">
                    <div class="stat-label">Avg Latency</div>
                    <div class="stat-value" id="avgLatency">0<span class="stat-unit">ms</span></div>
                </div>
                <div class="stat-card network">
                    <div class="stat-label">Avg Connect Time</div>
                    <div class="stat-value" id="avgConnect">0<span class="stat-unit">ms</span></div>
                </div>
                <div class="stat-card info">
                    <div class="stat-label">Error Rate</div>
                    <div class="stat-value" id="errorRate">0<span class="stat-unit">%</span></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Active Threads</div>
                    <div class="stat-value" id="activeThreads">0</div>
                </div>
            </div>

            <div id="aiInsights" class="ai-insights">
                <h2>ü§ñ AI-Powered Performance Analysis</h2>
                <div id="insightsContent"></div>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('overview')">üìà Overview</button>
                <button class="tab" onclick="switchTab('network')">üåê Network Analysis</button>
                <button class="tab" onclick="switchTab('response')">‚ö° Response Times</button>
                <button class="tab" onclick="switchTab('throughput')">üìä Throughput</button>
                <button class="tab" onclick="switchTab('errors')">‚ö†Ô∏è Errors</button>
            </div>

            <div id="overview-tab" class="tab-content active">
                <div class="dashboard-grid">
                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Response Time Percentiles</div>
                                <div class="chart-subtitle">Distribution across percentiles</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="percentileChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Response Time Timeline</div>
                                <div class="chart-subtitle">Real-time response pattern</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="timelineChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Throughput Over Time</div>
                                <div class="chart-subtitle">Requests per second</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="throughputChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Error Rate & Active Threads</div>
                                <div class="chart-subtitle">Error pattern and concurrent users</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="errorChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div id="network-tab" class="tab-content">
                <div class="dashboard-grid">
                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Network Latency Breakdown</div>
                                <div class="chart-subtitle">DNS, Connect, and Response time components</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="networkBreakdownChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Latency Over Time</div>
                                <div class="chart-subtitle">Network latency timeline</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="latencyTimelineChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Connection Time Analysis</div>
                                <div class="chart-subtitle">Time to establish connections</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="connectTimeChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Bytes Sent vs Received</div>
                                <div class="chart-subtitle">Network traffic analysis</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="bytesChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Network Latency Distribution</div>
                                <div class="chart-subtitle">Frequency of different latency ranges</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="latencyDistributionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Response vs Latency Correlation</div>
                                <div class="chart-subtitle">Relationship between response time and latency</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="responseVsLatencyChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="details-section">
                    <div class="details-title">Network Performance Metrics</div>
                    <table class="percentile-table">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Min (ms)</th>
                                <th>Avg (ms)</th>
                                <th>P95 (ms)</th>
                                <th>Max (ms)</th>
                            </tr>
                        </thead>
                        <tbody id="networkMetricsTable">
                            <tr><td colspan="5" style="text-align: center; padding: 20px;">Loading network metrics...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div id="response-tab" class="tab-content">
                <div class="dashboard-grid">
                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Response Time Distribution</div>
                                <div class="chart-subtitle">Histogram of response times</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="distributionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Response Time Heatmap</div>
                                <div class="chart-subtitle">Time vs Response Time intensity</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="heatmapChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div id="throughput-tab" class="tab-content">
                <div class="dashboard-grid">
                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Throughput Distribution</div>
                                <div class="chart-subtitle">Requests per second over time</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="throughputDistributionChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Request Rate by Minute</div>
                                <div class="chart-subtitle">Requests per minute</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="requestsPerMinuteChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <div id="errors-tab" class="tab-content">
                <div class="dashboard-grid">
                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Error Timeline</div>
                                <div class="chart-subtitle">When errors occurred during test</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="errorTimelineChart"></canvas>
                        </div>
                    </div>

                    <div class="chart-container">
                        <div class="chart-header">
                            <div>
                                <div class="chart-title">Error Types Distribution</div>
                                <div class="chart-subtitle">Breakdown of different error types</div>
                            </div>
                        </div>
                        <div class="chart-wrapper">
                            <canvas id="errorTypesChart"></canvas>
                        </div>
                    </div>
                </div>

                <div class="details-section">
                    <div class="details-title">‚ö†Ô∏è Error Analysis</div>
                    <div id="errorDetailsContent">
                        <div class="no-data">
                            <div class="no-data-icon">‚ö†Ô∏è</div>
                            <div>No error details available</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="details-section">
                <div class="details-title">Detailed Percentile Analysis</div>
                <table class="percentile-table">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th>Value (ms)</th>
                            <th>SLA Status</th>
                        </tr>
                    </thead>
                    <tbody id="percentileTable">
                        <tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        let charts = {};
        let chartData = null;
        let networkMetrics = null;
        let aggregatedMetrics = null;

        // Optimized streaming processor for 1GB files
        class StreamingProcessor {
            constructor() {
                this.chunkSize = 2 * 1024 * 1024; // 2MB chunks for better performance
                this.headers = null;
                this.metrics = {
                    count: 0,
                    successCount: 0,
                    sumResponse: 0,
                    sumLatency: 0,
                    sumConnect: 0,
                    sumBytes: 0,
                    sumSentBytes: 0,
                    maxThreads: 0,
                    minResponse: Infinity,
                    maxResponse: 0,
                    errors: new Map(),
                    timeBuckets: new Map()
                };
                this.reservoir = []; // Reservoir sampling for percentiles
                this.reservoirSize = 10000; // Keep 10k samples for percentile calculation
            }

            async processFile(file) {
                const totalSize = file.size;
                let offset = 0;
                let textBuffer = '';
                const reader = new FileReader();
                
                const progressBar = document.getElementById('progressBar');
                const progressContainer = document.getElementById('progressContainer');
                const statusDiv = document.getElementById('processingStatus');
                
                progressContainer.style.display = 'block';
                statusDiv.style.display = 'block';

                return new Promise((resolve, reject) => {
                    const readNextChunk = () => {
                        if (offset >= totalSize) {
                            // Final processing
                            if (textBuffer.trim()) {
                                this.processLine(textBuffer, offset);
                            }
                            
                            progressBar.style.width = '100%';
                            progressBar.textContent = '100%';
                            statusDiv.textContent = `Processing complete: ${this.metrics.count.toLocaleString()} records`;
                            
                            setTimeout(() => {
                                progressContainer.style.display = 'none';
                                resolve(this.getResults());
                            }, 500);
                            return;
                        }

                        const blob = file.slice(offset, offset + this.chunkSize);
                        reader.readAsText(blob);
                    };

                    reader.onload = (e) => {
                        textBuffer += e.target.result;
                        const lines = textBuffer.split('\n');
                        
                        // Keep last incomplete line in buffer
                        textBuffer = lines.pop() || '';
                        
                        lines.forEach((line, index) => {
                            if (offset === 0 && index === 0 && !this.headers) {
                                this.headers = line.split(',').map(h => h.trim());
                                return;
                            }
                            this.processLine(line, offset);
                        });
                        
                        // Update progress
                        const progress = Math.min(100, ((offset + this.chunkSize) / totalSize) * 100);
                        progressBar.style.width = progress + '%';
                        progressBar.textContent = Math.round(progress) + '%';
                        statusDiv.textContent = `Processing: ${this.metrics.count.toLocaleString()} records...`;
                        
                        offset += this.chunkSize;
                        
                        // Use setTimeout to prevent UI blocking
                        setTimeout(readNextChunk, 0);
                    };

                    reader.onerror = () => reject(new Error('Error reading file'));
                    
                    readNextChunk();
                });
            }

            processLine(line, currentOffset) {
                if (!line.trim() || !this.headers) return;
                
                const values = line.split(',');
                if (values.length < 3) return; // Skip invalid lines
                
                const record = {};
                this.headers.forEach((header, idx) => {
                    record[header] = values[idx]?.trim() || '';
                });
                
                // Parse critical fields
                const elapsed = parseInt(record.elapsed || record.Latency || 0) || 0;
                const latency = parseInt(record.Latency || 0) || 0;
                const connect = parseInt(record.Connect || 0) || 0;
                const bytes = parseInt(record.bytes || 0) || 0;
                const sentBytes = parseInt(record.sentBytes || 0) || 0;
                const threadCount = parseInt(record.allThreads || record.grpThreads || 1);
                const success = (record.success || 'true').toLowerCase() === 'true';
                const timestamp = parseInt(record.timeStamp || record.timestamp || Date.now());
                
                // Update metrics
                this.metrics.count++;
                if (success) this.metrics.successCount++;
                
                if (elapsed > 0) {
                    this.metrics.sumResponse += elapsed;
                    this.metrics.minResponse = Math.min(this.metrics.minResponse, elapsed);
                    this.metrics.maxResponse = Math.max(this.metrics.maxResponse, elapsed);
                    
                    // Reservoir sampling for percentiles
                    if (this.reservoir.length < this.reservoirSize) {
                        this.reservoir.push(elapsed);
                    } else {
                        const randomIndex = Math.floor(Math.random() * this.metrics.count);
                        if (randomIndex < this.reservoirSize) {
                            this.reservoir[randomIndex] = elapsed;
                        }
                    }
                }
                
                this.metrics.sumLatency += latency;
                this.metrics.sumConnect += connect;
                this.metrics.sumBytes += bytes;
                this.metrics.sumSentBytes += sentBytes;
                this.metrics.maxThreads = Math.max(this.metrics.maxThreads, threadCount);
                
                // Track errors
                if (!success) {
                    const errorKey = `${record.responseCode || 'Unknown'}: ${(record.responseMessage || 'Unknown').substring(0, 100)}`;
                    this.metrics.errors.set(errorKey, (this.metrics.errors.get(errorKey) || 0) + 1);
                }
                
                // Time bucket aggregation (5 second intervals)
                const bucketKey = Math.floor(timestamp / 5000) * 5000;
                if (!this.metrics.timeBuckets.has(bucketKey)) {
                    this.metrics.timeBuckets.set(bucketKey, {
                        count: 0,
                        sumResponse: 0,
                        sumLatency: 0,
                        sumConnect: 0,
                        errors: 0,
                        sumBytes: 0,
                        sumSentBytes: 0,
                        sumThreads: 0,
                        timestamp: bucketKey
                    });
                }
                
                const bucket = this.metrics.timeBuckets.get(bucketKey);
                bucket.count++;
                bucket.sumResponse += elapsed;
                bucket.sumLatency += latency;
                bucket.sumConnect += connect;
                bucket.sumBytes += bytes;
                bucket.sumSentBytes += sentBytes;
                bucket.sumThreads += threadCount;
                if (!success) bucket.errors++;
            }

            getResults() {
                // Calculate percentiles from reservoir
                const sorted = this.reservoir.sort((a, b) => a - b);
                const percentiles = {
                    min: this.metrics.minResponse === Infinity ? 0 : this.metrics.minResponse,
                    p50: this.getPercentile(sorted, 0.50),
                    p75: this.getPercentile(sorted, 0.75),
                    p90: this.getPercentile(sorted, 0.90),
                    p95: this.getPercentile(sorted, 0.95),
                    p99: this.getPercentile(sorted, 0.99),
                    max: this.metrics.maxResponse
                };

                // Process time buckets
                const buckets = Array.from(this.metrics.timeBuckets.values())
                    .sort((a, b) => a.timestamp - b.timestamp);
                
                const timelineData = buckets.map(bucket => ({
                    avg: bucket.count > 0 ? Math.round(bucket.sumResponse / bucket.count) : 0,
                    avgLatency: bucket.count > 0 ? Math.round(bucket.sumLatency / bucket.count) : 0,
                    avgConnect: bucket.count > 0 ? Math.round(bucket.sumConnect / bucket.count) : 0,
                    throughput: bucket.count / 5, // 5 second buckets
                    errorRate: bucket.count > 0 ? (bucket.errors / bucket.count) * 100 : 0,
                    threads: bucket.count > 0 ? bucket.sumThreads / bucket.count : 0,
                    count: bucket.count,
                    errors: bucket.errors,
                    bytes: bucket.bytes,
                    sentBytes: bucket.sentBytes
                }));

                const avgResponse = this.metrics.count > 0 ? this.metrics.sumResponse / this.metrics.count : 0;
                const avgLatency = this.metrics.count > 0 ? this.metrics.sumLatency / this.metrics.count : 0;
                const avgConnect = this.metrics.count > 0 ? this.metrics.sumConnect / this.metrics.count : 0;

                // Network metrics from reservoir
                const latencyReservoir = [];
                const connectReservoir = [];
                
                return {
                    totalRequests: this.metrics.count,
                    successCount: this.metrics.successCount,
                    failureCount: this.metrics.count - this.metrics.successCount,
                    successRate: this.metrics.count > 0 ? (this.metrics.successCount / this.metrics.count) * 100 : 0,
                    errorRate: this.metrics.count > 0 ? ((this.metrics.count - this.metrics.successCount) / this.metrics.count) * 100 : 0,
                    avgResponse,
                    avgLatency,
                    avgConnect,
                    maxThreads: this.metrics.maxThreads,
                    percentiles,
                    timelineData,
                    errors: this.metrics.errors,
                    testDuration: buckets.length * 5, // seconds
                    networkMetrics: {
                        latency: {
                            min: this.getPercentile(sorted, 0),
                            avg: avgLatency,
                            p95: percentiles.p95,
                            max: percentiles.max
                        },
                        connect: {
                            min: 0,
                            avg: avgConnect,
                            p95: percentiles.p95,
                            max: percentiles.max
                        }
                    }
                };
            }

            getPercentile(sortedArray, percentile) {
                if (sortedArray.length === 0) return 0;
                const index = Math.ceil(sortedArray.length * percentile) - 1;
                return sortedArray[Math.max(0, Math.min(index, sortedArray.length - 1))];
            }
        }

        document.getElementById('fileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (!file) return;

            // Check file size
            const maxSize = 1024 * 1024 * 1024; // 1GB
            if (file.size > maxSize) {
                alert('File size exceeds 1GB limit. Please upload a smaller file.');
                return;
            }

            document.getElementById('fileName').textContent = `‚úì Processing: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`;
            document.getElementById('fileName').classList.remove('hidden');

            try {
                const processor = new StreamingProcessor();
                const results = await processor.processFile(file);
                aggregatedMetrics = results;
                analyzeResults(results);
            } catch (error) {
                alert('Error processing file: ' + error.message);
                console.error(error);
            }
        });

        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');

            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + '-tab').classList.add('active');

            if (tabName === 'network' && aggregatedMetrics) {
                initializeNetworkTab();
            }
        }

        function analyzeResults(results) {
            if (!results || results.totalRequests === 0) {
                alert('No valid data found in file');
                return;
            }

            const throughput = results.totalRequests / results.testDuration;

            chartData = {
                percentiles: results.percentiles,
                timelineData: results.timelineData,
                networkMetrics: results.networkMetrics,
                testDuration: results.testDuration
            };

            networkMetrics = results.networkMetrics;

            // Update UI
            document.getElementById('totalRequests').textContent = results.totalRequests.toLocaleString();
            document.getElementById('successRate').innerHTML = `${results.successRate.toFixed(2)}<span class="stat-unit">%</span>`;
            document.getElementById('avgResponse').innerHTML = `${Math.round(results.avgResponse)}<span class="stat-unit">ms</span>`;
            document.getElementById('throughput').innerHTML = `${throughput.toFixed(2)}<span class="stat-unit">req/s</span>`;
            document.getElementById('avgLatency').innerHTML = `${Math.round(results.avgLatency)}<span class="stat-unit">ms</span>`;
            document.getElementById('avgConnect').innerHTML = `${Math.round(results.avgConnect)}<span class="stat-unit">ms</span>`;
            document.getElementById('errorRate').innerHTML = `${results.errorRate.toFixed(2)}<span class="stat-unit">%</span>`;
            document.getElementById('activeThreads').textContent = results.maxThreads;

            updatePercentileTable(results.percentiles);
            generateInsights({
                totalRequests: results.totalRequests,
                successRate: results.successRate,
                failureCount: results.failureCount,
                avg: Math.round(results.avgResponse),
                avgLatency: Math.round(results.avgLatency),
                avgConnect: Math.round(results.avgConnect),
                percentiles: results.percentiles,
                throughput: parseFloat(throughput.toFixed(2)),
                errorRate: results.errorRate,
                testDuration: results.testDuration
            });

            analyzeErrors(results.errors, results.totalRequests);
            document.getElementById('results').classList.remove('hidden');
            createAllCharts();
        }

        function analyzeErrors(errorMap, totalRequests) {
            const errorDetailsDiv = document.getElementById('errorDetailsContent');
            
            if (errorMap.size === 0) {
                errorDetailsDiv.innerHTML = '<div class="no-data"><div class="no-data-icon">‚úì</div><div>No errors detected</div></div>';
                return;
            }
            
            errorDetailsDiv.innerHTML = '';
            const sortedErrors = Array.from(errorMap.entries()).sort((a, b) => b[1] - a[1]);
            
            sortedErrors.forEach(([err, count]) => {
                const div = document.createElement('div');
                div.style.cssText = 'background: #991b1b; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 4px solid #ef4444;';
                div.innerHTML = `<strong>${err}</strong><br><span style="color: #fca5a5;">Count: ${count} (${((count / totalRequests) * 100).toFixed(2)}%)</span>`;
                errorDetailsDiv.appendChild(div);
            });
        }

        function createAllCharts() {
            Object.values(charts).forEach(chart => chart && chart.destroy());
            charts = {};
            
            createPercentileChart();
            createTimelineChart();
            createThroughputChart();
            createErrorChart();
            createDistributionChart();
            createHeatmapChart();
            createThroughputDistributionChart();
            createRequestsPerMinuteChart();
            createErrorTimelineChart();
            createErrorTypesChart();
        }

        function initializeNetworkTab() {
            createNetworkBreakdownChart();
            createLatencyTimelineChart();
            createConnectTimeChart();
            createBytesChart();
            createLatencyDistributionChart();
            createResponseVsLatencyChart();
            updateNetworkMetricsTable();
        }

        function createPercentileChart() {
            if (!chartData) return;
            const ctx = document.getElementById('percentileChart').getContext('2d');
            charts.percentile = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['MIN', 'P50', 'P75', 'P90', 'P95', 'P99', 'MAX'],
                    datasets: [{
                        label: 'Response Time (ms)',
                        data: Object.values(chartData.percentiles),
                        backgroundColor: ['#10b981', '#3b82f6', '#3b82f6', '#f59e0b', '#ef4444', '#ef4444', '#dc2626']
                    }]
                },
                options: getChartOptions()
            });
        }

        function createTimelineChart() {
            if (!chartData) return;
            const ctx = document.getElementById('timelineChart').getContext('2d');
            charts.timeline = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Response Time',
                        data: chartData.timelineData.map(d => d.avg),
                        borderColor: '#10b981',
                        backgroundColor: 'rgba(16, 185, 129, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createThroughputChart() {
            if (!chartData) return;
            const ctx = document.getElementById('throughputChart').getContext('2d');
            charts.throughput = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Throughput',
                        data: chartData.timelineData.map(d => d.throughput),
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createErrorChart() {
            if (!chartData) return;
            const ctx = document.getElementById('errorChart').getContext('2d');
            charts.error = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Error Rate',
                        data: chartData.timelineData.map(d => d.errorRate),
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        tension: 0.4,
                        fill: true,
                        yAxisID: 'y',
                        pointRadius: 0
                    }, {
                        label: 'Active Threads',
                        data: chartData.timelineData.map(d => d.threads),
                        borderColor: '#3b82f6',
                        tension: 0.4,
                        yAxisID: 'y1',
                        pointRadius: 0
                    }]
                },
                options: getChartOptions(true, true)
            });
        }

        function createDistributionChart() {
            if (!chartData || !chartData.percentiles) return;
            const ctx = document.getElementById('distributionChart').getContext('2d');
            
            // Create distribution from percentiles
            const buckets = [
                { label: '0-100ms', value: 0 },
                { label: '100-500ms', value: 0 },
                { label: '500-1000ms', value: 0 },
                { label: '1000-2000ms', value: 0 },
                { label: '2000ms+', value: 0 }
            ];
            
            // Estimate distribution based on percentiles
            const p = chartData.percentiles;
            if (p.p50 < 100) buckets[0].value = 50;
            else if (p.p50 < 500) buckets[1].value = 50;
            else if (p.p50 < 1000) buckets[2].value = 50;
            else if (p.p50 < 2000) buckets[3].value = 50;
            else buckets[4].value = 50;
            
            if (p.p95 < 100) buckets[0].value += 45;
            else if (p.p95 < 500) buckets[1].value += 45;
            else if (p.p95 < 1000) buckets[2].value += 45;
            else if (p.p95 < 2000) buckets[3].value += 45;
            else buckets[4].value += 45;
            
            charts.distribution = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: buckets.map(b => b.label),
                    datasets: [{
                        label: 'Estimated Distribution',
                        data: buckets.map(b => b.value),
                        backgroundColor: '#3b82f6'
                    }]
                },
                options: getChartOptions()
            });
        }

        function createHeatmapChart() {
            if (!chartData) return;
            const ctx = document.getElementById('heatmapChart').getContext('2d');
            
            // Sample data points from timeline
            const heatmapData = chartData.timelineData.slice(0, 100).map((d, i) => ({
                x: i * 5,
                y: d.avg,
                r: 5
            }));
            
            charts.heatmap = new Chart(ctx, {
                type: 'bubble',
                data: {
                    datasets: [{
                        label: 'Response Times',
                        data: heatmapData,
                        backgroundColor: heatmapData.map(p => {
                            if (p.y < 100) return 'rgba(16, 185, 129, 0.6)';
                            if (p.y < 500) return 'rgba(59, 130, 246, 0.6)';
                            if (p.y < 1000) return 'rgba(245, 158, 11, 0.6)';
                            return 'rgba(239, 68, 68, 0.6)';
                        })
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Time (s)', color: '#94a3b8' }, grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y: { title: { display: true, text: 'Response Time (ms)', color: '#94a3b8' }, grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function createThroughputDistributionChart() {
            if (!chartData) return;
            const ctx = document.getElementById('throughputDistributionChart').getContext('2d');
            charts.throughputDist = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Throughput',
                        data: chartData.timelineData.map(d => d.throughput),
                        backgroundColor: '#3b82f6'
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createRequestsPerMinuteChart() {
            if (!chartData) return;
            const ctx = document.getElementById('requestsPerMinuteChart').getContext('2d');
            const requestsPerMin = [];
            for (let i = 0; i < chartData.timelineData.length; i += 12) {
                const slice = chartData.timelineData.slice(i, i + 12);
                requestsPerMin.push(slice.reduce((sum, d) => sum + d.count, 0));
            }
            
            charts.reqPerMin = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: requestsPerMin.map((_, i) => `Min ${i + 1}`),
                    datasets: [{
                        label: 'Requests/Minute',
                        data: requestsPerMin,
                        backgroundColor: '#8b5cf6'
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createErrorTimelineChart() {
            if (!chartData || !chartData.timelineData) return;
            
            const ctx = document.getElementById('errorTimelineChart').getContext('2d');
            if (charts.errorTimeline) charts.errorTimeline.destroy();
            
            const errorCounts = chartData.timelineData.map(d => d.errors);
            const hasErrors = errorCounts.some(count => count > 0);
            
            if (!hasErrors) {
                ctx.canvas.style.display = 'none';
                const parent = ctx.canvas.parentElement;
                let noDataDiv = parent.querySelector('.no-data');
                if (!noDataDiv) {
                    noDataDiv = document.createElement('div');
                    noDataDiv.className = 'no-data';
                    noDataDiv.innerHTML = '<div class="no-data-icon">‚úì</div><div>No errors detected during test</div>';
                    parent.appendChild(noDataDiv);
                }
                return;
            }
            
            ctx.canvas.style.display = 'block';
            const parent = ctx.canvas.parentElement;
            const noDataDiv = parent.querySelector('.no-data');
            if (noDataDiv) noDataDiv.remove();
            
            charts.errorTimeline = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: errorCounts.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Errors',
                        data: errorCounts,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 2,
                        pointBackgroundColor: '#ef4444'
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createErrorTypesChart() {
            if (!aggregatedMetrics || !aggregatedMetrics.errors) return;
            
            const ctx = document.getElementById('errorTypesChart').getContext('2d');
            if (charts.errorTypes) charts.errorTypes.destroy();
            
            if (aggregatedMetrics.errors.size === 0) {
                ctx.canvas.style.display = 'none';
                const parent = ctx.canvas.parentElement;
                let noDataDiv = parent.querySelector('.no-data');
                if (!noDataDiv) {
                    noDataDiv = document.createElement('div');
                    noDataDiv.className = 'no-data';
                    noDataDiv.innerHTML = '<div class="no-data-icon">‚úì</div><div>No errors detected during test</div>';
                    parent.appendChild(noDataDiv);
                }
                return;
            }
            
            ctx.canvas.style.display = 'block';
            const parent = ctx.canvas.parentElement;
            const noDataDiv = parent.querySelector('.no-data');
            if (noDataDiv) noDataDiv.remove();
            
            const sortedErrors = Array.from(aggregatedMetrics.errors.entries())
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const labels = sortedErrors.map(e => e[0].substring(0, 30));
            const counts = sortedErrors.map(e => e[1]);
            
            charts.errorTypes = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: counts,
                        backgroundColor: [
                            '#ef4444', '#f97316', '#f59e0b', '#eab308',
                            '#84cc16', '#10b981', '#14b8a6', '#0ea5e9',
                            '#3b82f6', '#8b5cf6'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                color: '#94a3b8',
                                font: { size: 11 },
                                padding: 10
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const value = context.raw;
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((value / total) * 100).toFixed(1);
                                    return `${context.label}: ${value} (${percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function createNetworkBreakdownChart() {
            if (!networkMetrics) return;
            const ctx = document.getElementById('networkBreakdownChart').getContext('2d');
            charts.networkBreakdown = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Connect Time', 'Latency', 'Processing Time'],
                    datasets: [{
                        label: 'Average (ms)',
                        data: [
                            networkMetrics.connect.avg,
                            networkMetrics.latency.avg,
                            parseFloat(document.getElementById('avgResponse').textContent) - networkMetrics.latency.avg
                        ],
                        backgroundColor: ['#06b6d4', '#8b5cf6', '#10b981']
                    }]
                },
                options: getChartOptions()
            });
        }

        function createLatencyTimelineChart() {
            if (!chartData) return;
            const ctx = document.getElementById('latencyTimelineChart').getContext('2d');
            charts.latencyTimeline = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Latency',
                        data: chartData.timelineData.map(d => d.avgLatency),
                        borderColor: '#06b6d4',
                        backgroundColor: 'rgba(6, 182, 212, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createConnectTimeChart() {
            if (!chartData) return;
            const ctx = document.getElementById('connectTimeChart').getContext('2d');
            charts.connectTime = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Connect Time',
                        data: chartData.timelineData.map(d => d.avgConnect),
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 0
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createBytesChart() {
            if (!chartData) return;
            const ctx = document.getElementById('bytesChart').getContext('2d');
            charts.bytes = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartData.timelineData.map((_, i) => `${i * 5}s`),
                    datasets: [{
                        label: 'Bytes Received',
                        data: chartData.timelineData.map(d => d.bytes),
                        borderColor: '#10b981',
                        yAxisID: 'y'
                    }, {
                        label: 'Bytes Sent',
                        data: chartData.timelineData.map(d => d.sentBytes),
                        borderColor: '#3b82f6',
                        yAxisID: 'y'
                    }]
                },
                options: getChartOptions(true)
            });
        }

        function createLatencyDistributionChart() {
            if (!chartData) return;
            const ctx = document.getElementById('latencyDistributionChart').getContext('2d');
            
            // Create estimated distribution from timeline data
            const buckets = [
                { label: '0-50ms', value: 0 },
                { label: '50-100ms', value: 0 },
                { label: '100-200ms', value: 0 },
                { label: '200-500ms', value: 0 },
                { label: '500ms+', value: 0 }
            ];
            
            chartData.timelineData.forEach(d => {
                if (d.avgLatency < 50) buckets[0].value++;
                else if (d.avgLatency < 100) buckets[1].value++;
                else if (d.avgLatency < 200) buckets[2].value++;
                else if (d.avgLatency < 500) buckets[3].value++;
                else buckets[4].value++;
            });
            
            charts.latencyDist = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: buckets.map(b => b.label),
                    datasets: [{
                        label: 'Frequency',
                        data: buckets.map(b => b.value),
                        backgroundColor: '#06b6d4'
                    }]
                },
                options: getChartOptions()
            });
        }

        function createResponseVsLatencyChart() {
            if (!chartData) return;
            const ctx = document.getElementById('responseVsLatencyChart').getContext('2d');
            
            const scatterData = chartData.timelineData.slice(0, 100).map(d => ({
                x: d.avgLatency,
                y: d.avg
            }));
            
            charts.responseVsLatency = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Response vs Latency',
                        data: scatterData,
                        backgroundColor: 'rgba(6, 182, 212, 0.5)',
                        pointRadius: 3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: { title: { display: true, text: 'Latency (ms)', color: '#94a3b8' }, grid: { color: '#334155' }, ticks: { color: '#94a3b8' } },
                        y: { title: { display: true, text: 'Response Time (ms)', color: '#94a3b8' }, grid: { color: '#334155' }, ticks: { color: '#94a3b8' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function updateNetworkMetricsTable() {
            if (!networkMetrics) return;
            const tbody = document.getElementById('networkMetricsTable');
            tbody.innerHTML = `
                <tr>
                    <td>Latency</td>
                    <td>${networkMetrics.latency.min.toFixed(2)}</td>
                    <td>${networkMetrics.latency.avg.toFixed(2)}</td>
                    <td>${networkMetrics.latency.p95.toFixed(2)}</td>
                    <td>${networkMetrics.latency.max.toFixed(2)}</td>
                </tr>
                <tr>
                    <td>Connect Time</td>
                    <td>${networkMetrics.connect.min.toFixed(2)}</td>
                    <td>${networkMetrics.connect.avg.toFixed(2)}</td>
                    <td>${networkMetrics.connect.p95.toFixed(2)}</td>
                    <td>${networkMetrics.connect.max.toFixed(2)}</td>
                </tr>
            `;
        }

        function updatePercentileTable(percentiles) {
            const tbody = document.getElementById('percentileTable');
            const slaThresholds = {
                min: 0,
                p50: 4000,
                p75: 5500,
                p90: 6500,
                p95: 8000,
                p99: 11000,
                max: 15000
            };
            
            tbody.innerHTML = Object.entries(percentiles).map(([key, value]) => {
                const threshold = slaThresholds[key];
                const meetsSLA = value <= threshold;
                const status = meetsSLA 
                    ? '<span style="color:#10b981">‚úì Within SLA</span>' 
                    : `<span style="color:#ef4444">‚úó Exceeds by ${Math.round(value - threshold)}ms</span>`;
                
                return `<tr>
                    <td>${key.toUpperCase()}</td>
                    <td>${Math.round(value)} ms</td>
                    <td>${status}</td>
                </tr>`;
            }).join('');
        }

        function generateInsights(metrics) {
            let html = '<div class="insight-section"><h3>1. Overall Performance</h3>';
            
            let status, statusClass;
            if (metrics.successRate >= 99.5 && metrics.avg <= 500) {
                status = 'EXCELLENT';
                statusClass = 'status-excellent';
                html += '<p>Outstanding performance with excellent response times and high reliability.</p>';
            } else if (metrics.successRate >= 98 && metrics.avg <= 1000) {
                status = 'GOOD';
                statusClass = 'status-good';
                html += '<p>Good performance with acceptable response times.</p>';
            } else if (metrics.successRate >= 95 && metrics.avg <= 2000) {
                status = 'FAIR';
                statusClass = 'status-fair';
                html += '<p>Fair performance with room for improvement.</p>';
            } else {
                status = 'POOR';
                statusClass = 'status-poor';
                html += '<p>Performance issues detected. Immediate attention required.</p>';
            }
            
            html += `<span class="status-badge ${statusClass}">${status}</span></div>`;
            
            html += `<div class="insight-section"><h3>2. Network Analysis</h3><ul>`;
            html += `<li>Average Latency: ${metrics.avgLatency}ms - Network round-trip time</li>`;
            html += `<li>Average Connect Time: ${metrics.avgConnect}ms - Time to establish connection</li>`;
            
            const processingTime = metrics.avg - metrics.avgLatency;
            html += `<li>Server Processing Time: ~${Math.round(processingTime)}ms</li>`;
            
            if (metrics.avgConnect > 100) {
                html += '<li style="color:#ef4444">High connection time detected - consider connection pooling or CDN</li>';
            }
            if (metrics.avgLatency > 200) {
                html += '<li style="color:#f59e0b">High network latency - check network infrastructure and server location</li>';
            }
            
            html += '</ul></div>';
            
            html += `<div class="insight-section"><h3>3. Key Recommendations</h3><ul>`;
            
            if (metrics.percentiles.p95 > 2000) {
                html += '<li>P95 response time exceeds 2s - optimize slow queries and database operations</li>';
            }
            if (metrics.errorRate > 1) {
                html += '<li>Error rate above 1% - investigate root causes and implement retry mechanisms</li>';
            }
            if (metrics.throughput < 10) {
                html += '<li>Low throughput detected - consider scaling infrastructure or optimizing application code</li>';
            }
            
            html += '</ul></div>';
            
            document.getElementById('insightsContent').innerHTML = html;
        }

        function getChartOptions(showTime = false, dualAxis = false) {
            const opts = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { display: false, labels: { color: '#94a3b8' } } },
                scales: {
                    x: { grid: { color: '#334155', drawBorder: false }, ticks: { color: '#94a3b8', maxRotation: 45 } },
                    y: { grid: { color: '#334155', drawBorder: false }, ticks: { color: '#94a3b8' }, beginAtZero: true }
                }
            };
            
            if (showTime) opts.scales.x.title = { display: true, text: 'Time', color: '#94a3b8' };
            
            if (dualAxis) {
                opts.scales.y1 = {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    grid: { drawOnChartArea: false },
                    ticks: { color: '#3b82f6' },
                    beginAtZero: true
                };
            }
            
            return opts;
        }
    </script>
</body>
</html>
